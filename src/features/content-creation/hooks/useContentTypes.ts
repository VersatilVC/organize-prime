import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { useEffectiveOrganization } from '@/hooks/useEffectiveOrganization';
import { useEffect } from 'react';
import type { 
  ContentType, 
  CreateContentTypeForm, 
  UpdateContentTypeForm 
} from '../types/contentCreationTypes';

export function useContentTypes() {
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const { effectiveOrganizationId } = useEffectiveOrganization();

  const { data: contentTypes = [], isLoading, error } = useQuery({
    queryKey: ['content-types', effectiveOrganizationId],
    queryFn: async (): Promise<ContentType[]> => {
      if (!effectiveOrganizationId) {
        throw new Error('No organization selected');
      }

      const { data, error } = await supabase
        .from('content_types')
        .select('*')
        .eq('organization_id', effectiveOrganizationId)
        .order('usage_count', { ascending: false })
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching content types:', error);
        throw new Error('Failed to fetch content types');
      }

      console.log('📖 Fetched content types:', data);
      data?.forEach((contentType, index) => {
        if (contentType.examples && contentType.examples.length > 0) {
          console.log(`📝 Content type "${contentType.name}" has ${contentType.examples.length} examples:`, contentType.examples);
        }
      });

      return data || [];
    },
    enabled: !!effectiveOrganizationId,
    staleTime: 30 * 1000, // 30 seconds (reduced from 2 minutes)
    refetchInterval: 15 * 1000, // Refetch every 15 seconds for real-time status updates
  });

  // Set up real-time subscription for extraction status updates
  useEffect(() => {
    if (!effectiveOrganizationId) return;

    console.log('🔔 Setting up real-time subscription for content types extraction status');

    // Listen for forced cache refresh events
    const handleForceRefresh = () => {
      console.log('🔄 Force refresh triggered, invalidating cache');
      queryClient.invalidateQueries({ 
        queryKey: ['content-types', effectiveOrganizationId] 
      });
    };
    
    window.addEventListener('force-content-types-refresh', handleForceRefresh);

    const channel = supabase.channel('content-types-realtime')
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'content_types',
          filter: `organization_id=eq.${effectiveOrganizationId}`
        },
        (payload) => {
          console.log('📡 Content type status update received:', payload.new);
          
          // Invalidate and refetch the query immediately
          queryClient.invalidateQueries({ 
            queryKey: ['content-types', effectiveOrganizationId] 
          });
          
          // Also invalidate single content type queries
          if (payload.new?.id) {
            queryClient.invalidateQueries({ 
              queryKey: ['content-type', payload.new.id, effectiveOrganizationId] 
            });
          }
        }
      )
      .subscribe();

    return () => {
      console.log('🔕 Cleaning up content types real-time subscription');
      window.removeEventListener('force-content-types-refresh', handleForceRefresh);
      channel.unsubscribe();
    };
  }, [effectiveOrganizationId, queryClient]);

  const createContentTypeMutation = useMutation({
    mutationFn: async (formData: CreateContentTypeForm): Promise<ContentType> => {
      if (!effectiveOrganizationId) {
        throw new Error('No organization selected');
      }

      const insertData: any = {
        organization_id: effectiveOrganizationId,
        name: formData.name,
        description: formData.description || null,
        type_category: formData.type_category,
        target_word_count: formData.target_word_count || null,
        word_count_range: {}, // Keep empty object for N8N compatibility
        examples: formData.examples || [],
        style_guidelines: formData.style_guidelines || null,
        tone_preferences: formData.tone_preferences || [], // PostgreSQL text array
        custom_instructions: formData.custom_instructions || null,
        required_sections: formData.required_sections || [], // PostgreSQL text array
        content_structure: formData.content_structure || null,
        is_active: formData.is_active ?? true,
        is_default: formData.is_default ?? false,
        // slug will be auto-generated by trigger
      };

      console.log('💾 Database INSERT data:', insertData);
      console.log('🔍 Examples being sent:', JSON.stringify(insertData.examples, null, 2));


      const { data, error } = await supabase
        .from('content_types')
        .insert(insertData)
        .select()
        .single();

      if (error) {
        console.error('❌ Database insert error:', error);
        throw error;
      }
      
      console.log('✅ Successfully created content type:', data);
      console.log('🔍 Examples saved in database:', JSON.stringify(data.examples, null, 2));
      
      return data;
    },
    onSuccess: (newContentType) => {
      queryClient.invalidateQueries({ queryKey: ['content-types', effectiveOrganizationId] });
      toast({
        title: 'Success',
        description: `Content type "${newContentType.name}" created successfully`,
      });
    },
    onError: (error) => {
      toast({
        title: 'Error',
        description: 'Failed to create content type',
        variant: 'destructive',
      });
      console.error('Create content type error:', error);
    },
  });

  const updateContentTypeMutation = useMutation({
    mutationFn: async ({ id, ...updates }: UpdateContentTypeForm): Promise<ContentType> => {
      const updateData: any = {};
      
      if (updates.name !== undefined) updateData.name = updates.name;
      if (updates.description !== undefined) updateData.description = updates.description;
      if (updates.type_category !== undefined) updateData.type_category = updates.type_category;
      if (updates.target_word_count !== undefined) updateData.target_word_count = updates.target_word_count;
      if (updates.examples !== undefined) updateData.examples = updates.examples;
      if (updates.style_guidelines !== undefined) updateData.style_guidelines = updates.style_guidelines;
      if (updates.custom_instructions !== undefined) updateData.custom_instructions = updates.custom_instructions;
      if (updates.required_sections !== undefined) updateData.required_sections = updates.required_sections;
      if (updates.content_structure !== undefined) updateData.content_structure = updates.content_structure;
      if (updates.is_active !== undefined) updateData.is_active = updates.is_active;
      if (updates.is_default !== undefined) updateData.is_default = updates.is_default;
      
      // Always include these for N8N compatibility
      updateData.word_count_range = {};
      updateData.tone_preferences = []; // PostgreSQL text array


      const { data, error } = await supabase
        .from('content_types')
        .update(updateData)
        .eq('id', id)
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: (updatedContentType) => {
      queryClient.invalidateQueries({ queryKey: ['content-types', effectiveOrganizationId] });
      toast({
        title: 'Success',
        description: `Content type "${updatedContentType.name}" updated successfully`,
      });
    },
    onError: (error) => {
      toast({
        title: 'Error',
        description: 'Failed to update content type',
        variant: 'destructive',
      });
      console.error('Update content type error:', error);
    },
  });

  const deleteContentTypeMutation = useMutation({
    mutationFn: async (id: string): Promise<void> => {
      const { error } = await supabase
        .from('content_types')
        .delete()
        .eq('id', id);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['content-types', effectiveOrganizationId] });
      toast({
        title: 'Success',
        description: 'Content type deleted successfully',
      });
    },
    onError: (error) => {
      toast({
        title: 'Error',
        description: 'Failed to delete content type',
        variant: 'destructive',
      });
      console.error('Delete content type error:', error);
    },
  });

  const updateUsageCountMutation = useMutation({
    mutationFn: async (id: string): Promise<void> => {
      const { error } = await supabase.rpc('update_content_type_usage', {
        content_type_id: id
      });

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['content-types', effectiveOrganizationId] });
    },
    onError: (error) => {
      console.error('Update usage count error:', error);
    },
  });

  return {
    contentTypes,
    isLoading,
    error,
    createContentType: createContentTypeMutation.mutate,
    updateContentType: updateContentTypeMutation.mutate,
    deleteContentType: deleteContentTypeMutation.mutate,
    updateUsageCount: updateUsageCountMutation.mutate,
    isCreating: createContentTypeMutation.isPending,
    isUpdating: updateContentTypeMutation.isPending,
    isDeleting: deleteContentTypeMutation.isPending,
  };
}

// Hook for a single content type
export function useContentType(id: string | undefined) {
  const { effectiveOrganizationId } = useEffectiveOrganization();

  return useQuery({
    queryKey: ['content-type', id, effectiveOrganizationId],
    queryFn: async (): Promise<ContentType | null> => {
      if (!id || !effectiveOrganizationId) return null;

      const { data, error } = await supabase
        .from('content_types')
        .select('*')
        .eq('id', id)
        .eq('organization_id', effectiveOrganizationId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') return null; // Not found
        throw error;
      }

      return data;
    },
    enabled: !!id && !!effectiveOrganizationId,
    staleTime: 30 * 1000, // 30 seconds (reduced from 5 minutes)
    refetchInterval: 15 * 1000, // Refetch every 15 seconds for real-time status updates
  });
}