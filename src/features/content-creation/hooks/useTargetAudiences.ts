import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { useEffectiveOrganization } from '@/hooks/useEffectiveOrganization';
import type { 
  TargetAudience, 
  CreateTargetAudienceForm, 
  UpdateTargetAudienceForm 
} from '../types/contentCreationTypes';

export function useTargetAudiences() {
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const { effectiveOrganizationId } = useEffectiveOrganization();

  const { data: targetAudiences = [], isLoading, error } = useQuery({
    queryKey: ['target-audiences', effectiveOrganizationId],
    queryFn: async (): Promise<TargetAudience[]> => {
      if (!effectiveOrganizationId) {
        throw new Error('No organization selected');
      }

      const { data, error } = await supabase
        .from('target_audiences')
        .select('*')
        .eq('organization_id', effectiveOrganizationId)
        .order('usage_count', { ascending: false })
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching target audiences:', error);
        throw new Error('Failed to fetch target audiences');
      }

      return data || [];
    },
    enabled: !!effectiveOrganizationId,
    staleTime: 2 * 60 * 1000, // 2 minutes
  });

  const createTargetAudienceMutation = useMutation({
    mutationFn: async (formData: CreateTargetAudienceForm): Promise<TargetAudience> => {
      if (!effectiveOrganizationId) {
        throw new Error('No organization selected');
      }

      const insertData: any = {
        organization_id: effectiveOrganizationId,
        name: formData.name,
        description: formData.description || null,
        company_types: formData.company_types || [],
        industries: formData.industries || [],
        company_sizes: formData.company_sizes || [],
        job_titles: formData.job_titles || [],
        job_levels: formData.job_levels || [],
        departments: formData.departments || [],
        demographics: formData.demographics || {},
        interests: formData.interests || [],
        pain_points: formData.pain_points || [],
        goals: formData.goals || [],
        preferred_content_formats: formData.preferred_content_formats || [],
        communication_style: formData.communication_style || null,
        content_consumption_habits: formData.content_consumption_habits || {},
        ai_segments: formData.ai_segments || {},
        segment_analysis: formData.segment_analysis || null,
        is_active: formData.is_active ?? true,
        // slug will be auto-generated by trigger
      };

      const { data, error } = await supabase
        .from('target_audiences')
        .insert(insertData)
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: (newTargetAudience) => {
      queryClient.invalidateQueries({ queryKey: ['target-audiences', effectiveOrganizationId] });
      toast({
        title: 'Success',
        description: `Target audience "${newTargetAudience.name}" created successfully`,
      });
    },
    onError: (error) => {
      toast({
        title: 'Error',
        description: 'Failed to create target audience',
        variant: 'destructive',
      });
      console.error('Create target audience error:', error);
    },
  });

  const updateTargetAudienceMutation = useMutation({
    mutationFn: async ({ id, ...updates }: UpdateTargetAudienceForm): Promise<TargetAudience> => {
      const updateData: any = {};
      
      if (updates.name !== undefined) updateData.name = updates.name;
      if (updates.description !== undefined) updateData.description = updates.description;
      if (updates.company_types !== undefined) updateData.company_types = updates.company_types;
      if (updates.industries !== undefined) updateData.industries = updates.industries;
      if (updates.company_sizes !== undefined) updateData.company_sizes = updates.company_sizes;
      if (updates.job_titles !== undefined) updateData.job_titles = updates.job_titles;
      if (updates.job_levels !== undefined) updateData.job_levels = updates.job_levels;
      if (updates.departments !== undefined) updateData.departments = updates.departments;
      if (updates.demographics !== undefined) updateData.demographics = updates.demographics;
      if (updates.interests !== undefined) updateData.interests = updates.interests;
      if (updates.pain_points !== undefined) updateData.pain_points = updates.pain_points;
      if (updates.goals !== undefined) updateData.goals = updates.goals;
      if (updates.preferred_content_formats !== undefined) updateData.preferred_content_formats = updates.preferred_content_formats;
      if (updates.communication_style !== undefined) updateData.communication_style = updates.communication_style;
      if (updates.content_consumption_habits !== undefined) updateData.content_consumption_habits = updates.content_consumption_habits;
      if (updates.ai_segments !== undefined) updateData.ai_segments = updates.ai_segments;
      if (updates.segment_analysis !== undefined) updateData.segment_analysis = updates.segment_analysis;
      if (updates.is_active !== undefined) updateData.is_active = updates.is_active;

      const { data, error } = await supabase
        .from('target_audiences')
        .update(updateData)
        .eq('id', id)
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: (updatedTargetAudience) => {
      queryClient.invalidateQueries({ queryKey: ['target-audiences', effectiveOrganizationId] });
      toast({
        title: 'Success',
        description: `Target audience "${updatedTargetAudience.name}" updated successfully`,
      });
    },
    onError: (error) => {
      toast({
        title: 'Error',
        description: 'Failed to update target audience',
        variant: 'destructive',
      });
      console.error('Update target audience error:', error);
    },
  });

  const deleteTargetAudienceMutation = useMutation({
    mutationFn: async (id: string): Promise<void> => {
      const { error } = await supabase
        .from('target_audiences')
        .delete()
        .eq('id', id);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['target-audiences', effectiveOrganizationId] });
      toast({
        title: 'Success',
        description: 'Target audience deleted successfully',
      });
    },
    onError: (error) => {
      toast({
        title: 'Error',
        description: 'Failed to delete target audience',
        variant: 'destructive',
      });
      console.error('Delete target audience error:', error);
    },
  });

  const updateUsageCountMutation = useMutation({
    mutationFn: async (id: string): Promise<void> => {
      const { error } = await supabase.rpc('update_target_audience_usage', {
        audience_id: id
      });

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['target-audiences', effectiveOrganizationId] });
    },
    onError: (error) => {
      console.error('Update usage count error:', error);
    },
  });

  return {
    targetAudiences,
    isLoading,
    error,
    createTargetAudience: createTargetAudienceMutation.mutate,
    updateTargetAudience: updateTargetAudienceMutation.mutate,
    deleteTargetAudience: deleteTargetAudienceMutation.mutate,
    updateUsageCount: updateUsageCountMutation.mutate,
    isCreating: createTargetAudienceMutation.isPending,
    isUpdating: updateTargetAudienceMutation.isPending,
    isDeleting: deleteTargetAudienceMutation.isPending,
  };
}

// Hook for a single target audience
export function useTargetAudience(id: string | undefined) {
  const { effectiveOrganizationId } = useEffectiveOrganization();

  return useQuery({
    queryKey: ['target-audience', id, effectiveOrganizationId],
    queryFn: async (): Promise<TargetAudience | null> => {
      if (!id || !effectiveOrganizationId) return null;

      const { data, error } = await supabase
        .from('target_audiences')
        .select('*')
        .eq('id', id)
        .eq('organization_id', effectiveOrganizationId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') return null; // Not found
        throw error;
      }

      return data;
    },
    enabled: !!id && !!effectiveOrganizationId,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}